reverted:
--- b/glib/gmain.c
+++ a/glib/gmain.c
@@ -1118,6 +1118,29 @@
     }
 }
 
+/* See https://bugzilla.gnome.org/show_bug.cgi?id=761102 for
+ * the introduction of this.
+ *
+ * The main optimization is to avoid waking up the main
+ * context if a change is made by the current owner.
+ */
+static void
+conditional_wakeup (GMainContext *context)
+{
+  /* We want to signal wakeups in two cases:
+   *  1 When the context is owned by another thread
+   *  2 When the context owner is NULL (two subcases)
+   *   2a Possible if the context has never been acquired
+   *   2b Or if the context has no current owner
+   *
+   * At least case 2a) is necessary to ensure backwards compatibility with
+   * qemu's use of GMainContext.
+   * https://bugzilla.gnome.org/show_bug.cgi?id=761102#c14
+   */
+  if (context->owner != G_THREAD_SELF)
+    g_wakeup_signal (context->wakeup);
+}
+
 static guint
 g_source_attach_unlocked (GSource      *source,
                           GMainContext *context,
@@ -1164,8 +1187,8 @@
   /* If another thread has acquired the context, wake it up since it
    * might be in poll() right now.
    */
+  if (do_wakeup)
+    conditional_wakeup (context);
-  if (do_wakeup && context->owner && context->owner != G_THREAD_SELF)
-    g_wakeup_signal (context->wakeup);
 
   return source->source_id;
 }
@@ -1855,7 +1878,7 @@
     {
       /* Quite likely that we need to change the timeout on the poll */
       if (!SOURCE_BLOCKED (source))
+        conditional_wakeup (context);
-        g_wakeup_signal (context->wakeup);
       UNLOCK_CONTEXT (context);
     }
 }
@@ -4295,7 +4318,7 @@
   context->poll_changed = TRUE;
 
   /* Now wake up the main loop if it is waiting in the poll() */
+  conditional_wakeup (context);
-  g_wakeup_signal (context->wakeup);
 }
 
 /**
@@ -4355,7 +4378,7 @@
   context->poll_changed = TRUE;
 
   /* Now wake up the main loop if it is waiting in the poll() */
+  conditional_wakeup (context);
-  g_wakeup_signal (context->wakeup);
 }
 
 /**
